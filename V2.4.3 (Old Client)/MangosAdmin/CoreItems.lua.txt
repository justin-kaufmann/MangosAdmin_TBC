-- ================= CoreItems.lua =================

-- Lokale Caches und Strukturen
local MA_ItemCache     = {}
local MA_ItemPending   = {}
local MA_ItemListeners = {}

-- Unsichtbares Tooltip zum Nachladen von ItemInfos
local MA_HiddenTooltip = CreateFrame("GameTooltip", "MA_HiddenTooltip", UIParent, "GameTooltipTemplate")
MA_HiddenTooltip:SetOwner(UIParent, "ANCHOR_NONE")

-- Hilfsfunktion: Cache fÃ¼llen, wenn GetItemInfo verfÃ¼gbar
local function MA_TryFillCache(id)
  local name, link, quality, ilvl, minLevel, typeText, subTypeText, stack, equipLoc, texture = GetItemInfo(id)
  if name then
    MA_ItemCache[id] = {
      name     = name,
      link     = link,
      quality  = quality,
      ilvl     = ilvl,
      minLevel = minLevel,
      type     = typeText,
      subType  = subTypeText,
      stack    = stack,
      equipLoc = equipLoc,
      icon     = texture,
    }
    return true
  end
  return false
end

-- Listener benachrichtigen
local function MA_NotifyItemListeners(id)
  for _, cb in ipairs(MA_ItemListeners) do
    pcall(cb, id)
  end
end

-- Item anfordern (Pending + Tooltip triggern)
local function MA_RequestItem(id)
  if MA_ItemCache[id] or MA_ItemPending[id] then return end
  MA_ItemPending[id] = true
  MA_HiddenTooltip:SetHyperlink("item:"..id)
end

-- Loader-Frame prÃ¼ft Pending-Items regelmÃ¤ÃŸig
local MA_ItemLoader = CreateFrame("Frame")
MA_ItemLoader:SetScript("OnUpdate", function()
  for id in pairs(MA_ItemPending) do
    if MA_TryFillCache(id) then
      MA_ItemPending[id] = nil
      MA_NotifyItemListeners(id)
    end
  end
end)

-- Ã–ffentliche API: Listener registrieren
function MangosAdmin.RegisterItemInfoListener(cb)
  table.insert(MA_ItemListeners, cb)
end

-- Ã–ffentliche API: Optionsliste fÃ¼r Dropdowns
function MangosAdmin.GetItemOptions()
  local opts, grouped = {}, {}
  for id, name in pairs(MangosAdminDB.items or {}) do
    local info = MA_ItemCache[id]
    if not info then
      if MA_TryFillCache(id) then
        info = MA_ItemCache[id]
      else
        MA_RequestItem(id)
      end
    end

    local itemName, itemType, itemSubType, equipLoc
    if info then
      itemName, itemType, itemSubType, equipLoc = info.name, info.type, info.subType, info.equipLoc
    else
      itemName, itemType, itemSubType, equipLoc = name, "Sonstiges", "Allgemein", nil
    end

    -- Fallback fÃ¼r Typ/Subtyp
    if (not itemType or itemType == "") and equipLoc and equipLoc ~= "" then
      if equipLoc:find("WEAPON") then
        itemType = "Waffe"
      elseif equipLoc:find("TRINKET") then
        itemType = "Schmuck"
      else
        itemType = "RÃ¼stung"
      end
      itemSubType = "Unbekannt"
    end

    itemType    = itemType    or "Sonstiges"
    itemSubType = itemSubType or "Allgemein"

    grouped[itemType] = grouped[itemType] or {}
    grouped[itemType][itemSubType] = grouped[itemType][itemSubType] or {}
    table.insert(grouped[itemType][itemSubType], {
      value = id,
      text  = (itemName or name).." ("..id..")",
      kind  = "item"
    })
  end

  -- Sortierung
  local catNames = {}
  for cat in pairs(grouped) do table.insert(catNames, cat) end
  table.sort(catNames)
  for _, cat in ipairs(catNames) do
    table.insert(opts, { text=cat, kind="category" })
    local subs = grouped[cat]
    local subNames = {}
    for sub in pairs(subs) do table.insert(subNames, sub) end
    table.sort(subNames)
    for _, sub in ipairs(subNames) do
      table.insert(opts, { text=sub, kind="sub" })
      table.sort(subs[sub], function(a,b) return a.text < b.text end)
      for _, it in ipairs(subs[sub]) do
        table.insert(opts, it)
      end
    end
  end
  return opts
end
